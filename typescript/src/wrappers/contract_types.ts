/** types required for contract interop */

/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0
 *
 * The greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)
 */
export type Decimal256 = string;
/**
 * The overall ideas of the Token API are: 1. use the Number type, not u128 or Uint128 2. abstract over the Cw20/Native variants
 *
 * At the end of the day, call transfer/query with the same business logic as contract math and don't worry at all about conversions or addresses/denoms
 */
export type Token =
  | {
      cw20: {
        /**
         * Address of the contract
         */
        addr: RawAddr;
        /**
         * Decimals places used by the contract
         */
        decimal_places: number;
      };
    }
  | {
      native: {
        /**
         * Decimal places used by the asset
         */
        decimal_places: number;
        /**
         * Native coin denom string
         */
        denom: string;
      };
    };
/**
 * A raw address passed in via JSON.
 *
 * The purpose of this newtype wrapper is to make it clear at the type level if a parameter is an address, and ensure that we go through a proper validation step when using it.
 */
export type RawAddr = string;
export type NonZeroDecimal = string;
/**
 * Unsigned value
 */
export type Usd = Decimal256;
/**
 * Unsigned value
 */
export type Collateral = Decimal256;
/**
 * Maximum liquidity for deposit.
 *
 * Note that this limit can be exceeded due to changes in collateral asset price or impairment.
 */
export type MaxLiquidity =
  | {
      unlimited: {};
    }
  | {
      usd: {
        /**
         * Amount in USD
         */
        amount: NonZeroDecimal;
      };
    };
/**
 * Spot price config
 */
export type SpotPriceConfig =
  | {
      manual: {
        /**
         * The admin address for manual spot price updates
         */
        admin: Addr;
      };
    }
  | {
      oracle: {
        /**
         * sequence of spot price feeds which are composed to generate a single spot price
         */
        feeds: SpotPriceFeed[];
        /**
         * if necessary, sequence of spot price feeds which are composed to generate a single USD spot price
         */
        feeds_usd: SpotPriceFeed[];
        /**
         * Pyth configuration, required on chains that use pyth feeds
         */
        pyth?: PythConfig | null;
        /**
         * Stride configuration, required on chains that use stride
         */
        stride?: StrideConfig | null;
      };
    };
/**
 * A human readable address.
 *
 * In Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.
 *
 * This type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.
 *
 * This type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.
 */
export type Addr = string;
/**
 * The data for an individual spot price feed
 */
export type SpotPriceFeedData =
  | {
      constant: {
        /**
         * The constant price
         */
        price: NonZeroDecimal;
      };
    }
  | {
      pyth: {
        /**
         * The identifier on pyth
         */
        id: Identifier;
      };
    }
  | {
      stride: {
        /**
         * The IBC denom for the asset
         */
        denom: string;
      };
    }
  | {
      sei: {
        /**
         * The denom to use
         */
        denom: string;
      };
    };
export type Identifier = string;
/**
 * Which network to use for the price service
 */
export type PythPriceServiceNetwork = "stable" | "edge";
/**
 * Essentially a newtype wrapper for [Timestamp] providing additional impls.
 *
 * Internal representation in nanoseconds since the epoch. We keep a [u64] directly (instead of a [Timestamp] or [cosmwasm_std::Uint64]) to make it easier to derive some impls. The result is that we need to explicitly implement [Serialize] and [Deserialize] to keep the stringy representation.
 */
export type Timestamp = string;
/**
 * Unsigned value
 */
export type LpToken = Decimal256;
/**
 * Unsigned value
 */
export type Notional = Decimal256;
export type MarketId = string;
/**
 * Whether the collateral asset is the same as the quote or base asset.
 */
export type MarketType = "collateral_is_quote" | "collateral_is_base";
/**
 * What work is currently available for the crank.
 */
export type CrankWorkInfo =
  | {
      close_all_positions: {
        /**
         * Next position to be closed
         */
        position: PositionId;
      };
    }
  | {
      reset_lp_balances: {};
    }
  | {
      liquifunding: {
        /**
         * Next position to be liquifunded
         */
        position: PositionId;
      };
    }
  | {
      unpend_liquidation_prices: {
        /**
         * Which position to process next
         */
        position: PositionId;
      };
    }
  | {
      liquidation: {
        /**
         * Reason for the liquidation
         */
        liquidation_reason: LiquidationReason;
        /**
         * Position to liquidate
         */
        position: PositionId;
        /**
         * price point that triggered the liquidation
         */
        price_point: PricePoint;
      };
    }
  | {
      limit_order: {
        /**
         * ID of the order to be opened
         */
        order_id: OrderId;
      };
    }
  | {
      completed: {
        /**
         * Timestamp of the price update
         */
        price_point_timestamp: Timestamp;
      };
    };
/**
 * PositionId
 */
export type PositionId = Uint64;
/**
 * A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.
 *
 * # Examples
 *
 * Use `from` to create instances of this and `u64` to get the value out:
 *
 * ``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);
 *
 * let b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```
 */
export type Uint64 = string;
/**
 * Reason why a position was liquidated
 */
export type LiquidationReason = "liquidated" | "max_gains" | "stop_loss" | "take_profit";
/**
 * The price of the currency pair, given as `quote / base`, e.g. "20,000 USD per BTC".
 */
export type PriceBaseInQuote = NonZeroDecimal;
/**
 * The price of the pair as used internally by the protocol, given as `collateral / notional`.
 */
export type Price = NonZeroDecimal;
/**
 * PriceBaseInQuote converted to USD
 */
export type PriceCollateralInUsd = NonZeroDecimal;
/**
 * A unique numeric ID for each order in the protocol.
 */
export type OrderId = Uint64;

/**
 * Overall market status information
 *
 * Returned from [QueryMsg::Status]
 */
export interface StatusResp {
  /**
   * Base asset
   */
  base: string;
  /**
   * Overall borrow fee rate (annualized), combining LP and xLP
   */
  borrow_fee: Decimal256;
  /**
   * LP component of [Self::borrow_fee]
   */
  borrow_fee_lp: Decimal256;
  /**
   * xLP component of [Self::borrow_fee]
   */
  borrow_fee_xlp: Decimal256;
  /**
   * The asset used for collateral within the system
   */
  collateral: Token;
  /**
   * Config for this market
   */
  config: Config;
  /**
   * Are we in the congested state where new positions cannot be opened?
   */
  congested: boolean;
  /**
   * Amount of collateral in the delta neutrality fee fund.
   */
  delta_neutrality_fee_fund: Collateral;
  /**
   * Fees held by the market contract
   */
  fees: Fees;
  /**
   * Instant delta neutrality fee value
   *
   * This is based on net notional and the sensitivity parameter
   */
  instant_delta_neutrality_fee_value: string;
  /**
   * Timestamp of the last completed crank
   */
  last_crank_completed?: Timestamp | null;
  /**
   * Current status of the liquidity pool
   */
  liquidity: LiquidityStats;
  /**
   * Long funding rate (annualized)
   */
  long_funding: string;
  /**
   * Total long interest, given in the notional asset.
   */
  long_notional: Notional;
  /**
   * Total long interest, given in USD, converted at the current exchange rate.
   */
  long_usd: Usd;
  /**
   * This market's identifier
   */
  market_id: MarketId;
  /**
   * Type of market
   */
  market_type: MarketType;
  /**
   * Next bit of crank work available, if any
   */
  next_crank?: CrankWorkInfo | null;
  /**
   * Quote asset
   */
  quote: string;
  /**
   * Short funding rate (annualized)
   */
  short_funding: string;
  /**
   * Total short interest, given in the notional asset.
   */
  short_notional: Notional;
  /**
   * Total short interest, given in USD, converted at the current exchange rate.
   */
  short_usd: Usd;
  /**
   * Have we reached staleness of the protocol via old liquifundings? If so, contains [Option::Some], and the timestamp when that happened.
   */
  stale_liquifunding?: Timestamp | null;
  /**
   * Is the last price update too old? If so, contains [Option::Some], and the timestamp when the price became too old.
   */
  stale_price?: Timestamp | null;
  /**
   * Size of the unpend queue
   */
  unpend_queue_size: number;
}
/**
 * Configuration info for the vAMM Set by admin-only Since this tends to cross the message boundary all the numeric types are u32 or lower helper functions are available where more bits are needed
 */
export interface Config {
  /**
   * The maximum annualized rate for borrow fee payments
   */
  borrow_fee_rate_max_annualized: NonZeroDecimal;
  /**
   * The minimum annualized rate for borrow fee payments
   */
  borrow_fee_rate_min_annualized: NonZeroDecimal;
  /**
   * Borrow fee sensitivity parameter.
   *
   * See [section 5.5 of the whitepaper](https://www.notion.so/levana-protocol/Levana-Well-funded-Perpetuals-Whitepaper-9805a6eba56d429b839f5551dbb65c40#295f9f2689e74ccab16ca28177eb32cb).
   */
  borrow_fee_sensitivity: NonZeroDecimal;
  /**
   * Needed to ensure financial model is balanced
   *
   * Must be at most 1 less than the [Config::max_leverage]
   */
  carry_leverage: Decimal256;
  /**
   * default number of crank exeuctions to do when none specified
   */
  crank_execs: number;
  /**
   * The crank fee to be paid into the system, in collateral
   */
  crank_fee_charged: Usd;
  /**
   * The crank fee to be sent to crankers, in collateral
   */
  crank_fee_reward: Usd;
  /**
   * Delta neutrality fee cap parameter, given as a percentage
   */
  delta_neutrality_fee_cap: NonZeroDecimal;
  /**
   * Delta neutrality fee sensitivity parameter.
   */
  delta_neutrality_fee_sensitivity: NonZeroDecimal;
  /**
   * Proportion of delta neutrality inflows that are sent to the protocol.
   */
  delta_neutrality_fee_tax: Decimal256;
  /**
   * Disable the ability to proxy CW721 execution messages for positions. Even if this is true, queries will still work as usual.
   */
  disable_position_nft_exec?: boolean;
  /**
   * The maximum annualized rate for a funding payment
   */
  funding_rate_max_annualized: Decimal256;
  /**
   * Impacts how much the funding rate changes in response to net notional changes.
   */
  funding_rate_sensitivity: Decimal256;
  /**
   * The fee to set a [super::entry::ExecuteMsg::PlaceLimitOrder]
   */
  limit_order_fee: Collateral;
  /**
   * The liquidity cooldown period.
   *
   * After depositing new funds into the market, liquidity providers will have a period of time where they cannot withdraw their funds. This is intended to prevent an MEV attack where someone can reorder transactions to extract fees from traders without taking on any impairment risk.
   *
   * This protection is only triggered by deposit of new funds; reinvesting existing yield does not introduce a cooldown.
   *
   * While the cooldown is in place, providers are prevented from either withdrawing liquidity or transferring their LP and xLP tokens.
   *
   * For migration purposes, this value defaults to 0, meaning no cooldown period.
   */
  liquidity_cooldown_seconds?: number;
  /**
   * The liquifunding delay fuzz factor, in seconds.
   *
   * Up to how many seconds will we perform a liquifunding early. This will be part of a semi-randomly generated value and will allow us to schedule liquifundings arbitrarily to smooth out spikes in traffic.
   */
  liquifunding_delay_fuzz_seconds?: number;
  /**
   * Delay between liquifundings, in seconds
   */
  liquifunding_delay_seconds: number;
  /**
   * The maximum allowed leverage when opening a position
   */
  max_leverage: string;
  /**
   * The maximum amount of liquidity that can be deposited into the market.
   */
  max_liquidity?: MaxLiquidity;
  /**
   * Maximum multiplier for xLP versus LP borrow fee shares.
   *
   * For example, if this number is 5, then as liquidity in the protocol approaches 100% in LP and 0% in xLP, any xLP token will receive 5x the rewards of an LP token.
   */
  max_xlp_rewards_multiplier: NonZeroDecimal;
  /**
   * Minimum counterpoint to [Config::max_xlp_rewards_multiplier]
   */
  min_xlp_rewards_multiplier: NonZeroDecimal;
  /**
   * Minimum deposit collateral, given in USD
   */
  minimum_deposit_usd: Usd;
  /**
   * Do not emit events (default is false, events *will* be emitted)
   */
  mute_events: boolean;
  /**
   * How old must the latest price update be to trigger the protocol to lock?
   */
  price_update_too_old_seconds: number;
  /**
   * The percentage of fees that are taken for the protocol
   */
  protocol_tax: Decimal256;
  /**
   * The spot price config for this market
   */
  spot_price: SpotPriceConfig;
  /**
   * How far behind must the position liquifunding process be to consider the protocol stale?
   */
  staleness_seconds: number;
  /**
   * Target utilization ratio liquidity, given as a ratio. (Must be between 0 and 1).
   */
  target_utilization: NonZeroDecimal;
  /**
   * The fee to open a position, as a percentage of the counter-side collateral
   */
  trading_fee_counter_collateral: Decimal256;
  /**
   * The fee to open a position, as a percentage of the notional size
   */
  trading_fee_notional_size: Decimal256;
  /**
   * How many positions can sit in "unpend" before we disable new open/update positions for congestion.
   */
  unpend_limit?: number;
  /**
   * How long it takes to unstake xLP tokens into LP tokens, in seconds
   */
  unstake_period_seconds: number;
}
/**
 * An individual feed used to compose a final spot price
 */
export interface SpotPriceFeed {
  /**
   * The data for this price feed
   */
  data: SpotPriceFeedData;
  /**
   * is this price feed inverted
   */
  inverted: boolean;
}
/**
 * Configuration for pyth
 */
export interface PythConfig {
  /**
   * The age tolerance for pyth price updates
   */
  age_tolerance_seconds: number;
  /**
   * The address of the pyth oracle contract
   */
  contract_address: Addr;
  /**
   * Which network to use for the price service This isn't used for any internal logic, but clients must use the appropriate price service endpoint to match this
   */
  network: PythPriceServiceNetwork;
}
/**
 * Configuration for stride
 */
export interface StrideConfig {
  /**
   * The address of the redemption rate contract
   */
  contract_address: Addr;
}
/**
 * Fees held within the market contract.
 */
export interface Fees {
  /**
   * Crank fees collected and waiting to be allocated to crankers.
   */
  crank: Collateral;
  /**
   * Fees available for the protocol overall to withdraw.
   */
  protocol: Collateral;
  /**
   * Fees available for individual wallets to withdraw.
   */
  wallets: Collateral;
}
/**
 * Protocol wide stats on liquidity
 */
export interface LiquidityStats {
  /**
   * Collateral locked as counter collateral in the protocol
   */
  locked: Collateral;
  /**
   * Total number of LP tokens
   */
  total_lp: LpToken;
  /**
   * Total number of xLP tokens
   */
  total_xlp: LpToken;
  /**
   * Total amount of collateral available to be used as liquidity
   */
  unlocked: Collateral;
}
/**
 * All prices in the protocol for a given point in time.
 *
 * This includes extra information necessary for performing all conversions, such as the [MarketType].
 */
export interface PricePoint {
  /**
   * Is the notional asset USD?
   *
   * Used for avoiding lossy conversions to USD when they aren't needed.
   *
   * We do not need to track if the collateral asset is USD, since USD can never be used as collateral directly. Instead, stablecoins would be used, in which case an explicit price to USD is always needed.
   */
  is_notional_usd: boolean;
  /**
   * Indicates if this market uses collateral as base or quote, needed for price conversions.
   */
  market_type: MarketType;
  /**
   * Price of the base asset in terms of the quote.
   */
  price_base: PriceBaseInQuote;
  /**
   * Price as used internally by the protocol, in terms of collateral and notional.
   *
   * This is generally less useful for external consumers, where [PricePoint::price_usd] and [PricePoint::price_base] are used.
   */
  price_notional: Price;
  /**
   * Price of the collateral asset in terms of USD.
   *
   * This is generally used for reporting of values like PnL and trade volume.
   */
  price_usd: PriceCollateralInUsd;
  /**
   * Latest price publish time for the feeds composing the price, if available
   */
  publish_time?: Timestamp | null;
  /**
   * Latest price publish time for the feeds composing the price_usd, if available
   */
  publish_time_usd?: Timestamp | null;
  /**
   * Timestamp of when this price was entered into the system.
   */
  timestamp: Timestamp;
}

/**
 * Execute message for the market contract
 */
export type ExecuteMsg =
  | {
      owner: ExecuteOwnerMsg;
    }
  | {
      receive: {
        /**
         * Amount of funds sent
         */
        amount: Uint128;
        /**
         * Must parse to a [ExecuteMsg]
         */
        msg: Binary;
        /**
         * Owner of funds sent to the contract
         */
        sender: RawAddr;
      };
    }
  | {
      open_position: {
        /**
         * Direction of new position
         */
        direction: DirectionToBase;
        /**
         * Leverage of new position
         */
        leverage: LeverageToBase;
        /**
         * Maximum gains of new position
         */
        max_gains: MaxGainsInQuote;
        /**
         * Assertion that the price has not moved too far
         */
        slippage_assert?: SlippageAssert | null;
        /**
         * Stop loss price of new position
         */
        stop_loss_override?: PriceBaseInQuote | null;
        /**
         * Take profit price of new position
         */
        take_profit_override?: PriceBaseInQuote | null;
      };
    }
  | {
      update_position_add_collateral_impact_leverage: {
        /**
         * ID of position to update
         */
        id: PositionId;
      };
    }
  | {
      update_position_add_collateral_impact_size: {
        /**
         * ID of position to update
         */
        id: PositionId;
        /**
         * Assertion that the price has not moved too far
         */
        slippage_assert?: SlippageAssert | null;
      };
    }
  | {
      update_position_remove_collateral_impact_leverage: {
        /**
         * Amount of funds to remove from the position
         */
        amount: NonZeroDecimal;
        /**
         * ID of position to update
         */
        id: PositionId;
      };
    }
  | {
      update_position_remove_collateral_impact_size: {
        /**
         * Amount of funds to remove from the position
         */
        amount: NonZeroDecimal;
        /**
         * ID of position to update
         */
        id: PositionId;
        /**
         * Assertion that the price has not moved too far
         */
        slippage_assert?: SlippageAssert | null;
      };
    }
  | {
      update_position_leverage: {
        /**
         * ID of position to update
         */
        id: PositionId;
        /**
         * New leverage of the position
         */
        leverage: LeverageToBase;
        /**
         * Assertion that the price has not moved too far
         */
        slippage_assert?: SlippageAssert | null;
      };
    }
  | {
      update_position_max_gains: {
        /**
         * ID of position to update
         */
        id: PositionId;
        /**
         * New max gains of the position
         */
        max_gains: MaxGainsInQuote;
      };
    }
  | {
      set_trigger_order: {
        /**
         * ID of position to modify
         */
        id: PositionId;
        /**
         * New stop loss price of the position
         */
        stop_loss_override?: PriceBaseInQuote | null;
        /**
         * New take profit price of the position
         */
        take_profit_override?: PriceBaseInQuote | null;
      };
    }
  | {
      place_limit_order: {
        /**
         * Direction of new position
         */
        direction: DirectionToBase;
        /**
         * Leverage of new position
         */
        leverage: LeverageToBase;
        /**
         * Max gains of new position
         */
        max_gains: MaxGainsInQuote;
        /**
         * Stop loss price of new position
         */
        stop_loss_override?: PriceBaseInQuote | null;
        /**
         * Take profit price of new position
         */
        take_profit_override?: PriceBaseInQuote | null;
        /**
         * Price when the order should trigger
         */
        trigger_price: PriceBaseInQuote;
      };
    }
  | {
      cancel_limit_order: {
        /**
         * ID of the order
         */
        order_id: OrderId;
      };
    }
  | {
      close_position: {
        /**
         * ID of position to close
         */
        id: PositionId;
        /**
         * Assertion that the price has not moved too far
         */
        slippage_assert?: SlippageAssert | null;
      };
    }
  | {
      deposit_liquidity: {
        /**
         * Should we stake the resulting LP tokens into xLP?
         *
         * Defaults to `false`.
         */
        stake_to_xlp?: boolean;
      };
    }
  | {
      reinvest_yield: {
        /**
         * Amount of rewards to reinvest.
         *
         * If `None`, reinvests all pending rewards.
         */
        amount?: NonZeroDecimal | null;
        /**
         * Should we stake the resulting LP tokens into xLP?
         *
         * Defaults to `false`.
         */
        stake_to_xlp?: boolean;
      };
    }
  | {
      withdraw_liquidity: {
        /**
         * Amount of LP tokens to burn
         */
        lp_amount?: NonZeroDecimal | null;
      };
    }
  | {
      claim_yield: {};
    }
  | {
      stake_lp: {
        /**
         * Amount of LP tokens to convert into xLP.
         */
        amount?: NonZeroDecimal | null;
      };
    }
  | {
      unstake_xlp: {
        /**
         * Amount of xLP tokens to convert into LP
         */
        amount?: NonZeroDecimal | null;
      };
    }
  | {
      stop_unstaking_xlp: {};
    }
  | {
      collect_unstaked_lp: {};
    }
  | {
      crank: {
        /**
         * Total number of crank executions to do None: config default
         */
        execs?: number | null;
        /**
         * Which wallet receives crank rewards.
         *
         * If unspecified, sender receives the rewards.
         */
        rewards?: RawAddr | null;
      };
    }
  | {
      nft_proxy: {
        /**
         * Message sent to the NFT proxy
         */
        msg: NftExecuteMsg;
        /**
         * Original caller of the NFT proxy.
         */
        sender: RawAddr;
      };
    }
  | {
      liquidity_token_proxy: {
        /**
         * Whether this was the LP or xLP proxy.
         */
        kind: LiquidityTokenKind;
        /**
         * Message sent to the liquidity token proxy.
         */
        msg: Cw20ExecuteMsg;
        /**
         * Original caller of the liquidity token proxy.
         */
        sender: RawAddr;
      };
    }
  | {
      transfer_dao_fees: {};
    }
  | {
      close_all_positions: {};
    }
  | {
      provide_crank_funds: {};
    }
  | {
      set_manual_price: {
        /**
         * Price of the base asset in terms of the quote.
         */
        price: PriceBaseInQuote;
        /**
         * Price of the collateral asset in terms of USD.
         *
         * This is generally used for reporting of values like PnL and trade volume.
         */
        price_usd: PriceCollateralInUsd;
      };
    };
/**
 * Owner-only messages
 */
export type ExecuteOwnerMsg = {
  config_update: {
    /**
     * New configuration parameters
     */
    update: ConfigUpdate;
  };
};
/**
 * A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.
 *
 * # Examples
 *
 * Use `from` to create instances of this and `u128` to get the value out:
 *
 * ``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);
 *
 * let b = Uint128::from(42u64); assert_eq!(b.u128(), 42);
 *
 * let c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```
 */
export type Uint128 = string;
/**
 * Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.
 *
 * This is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.
 */
export type Binary = string;
/**
 * Direction in terms of base
 */
export type DirectionToBase = "long" | "short";
/**
 * The absolute leverage for a position, in terms of the base asset.
 *
 * Note that while leverage specified by the trader must be strictly positive (greater than 0), this type allows zero leverage to occur, since calculated leverage within the system based on the off-by-one exposure calculation may end up as 0.
 */
export type LeverageToBase = Decimal256;
export type MaxGainsInQuote = string;
/**
 * Execute messages for a position token proxy
 *
 * Matches the CW721 standard.
 */
export type NftExecuteMsg =
  | {
      transfer_nft: {
        /**
         * Recipient of the NFT (position)
         */
        recipient: RawAddr;
        /**
         * Position ID, represented as a `String` to match the NFT spec
         */
        token_id: string;
      };
    }
  | {
      send_nft: {
        /**
         * Contract to receive the position
         */
        contract: RawAddr;
        /**
         * Message to execute on the contract
         */
        msg: Binary;
        /**
         * Position ID, represented as a `String` to match the NFT spec
         */
        token_id: string;
      };
    }
  | {
      approve: {
        /**
         * When the approval expires
         */
        expires?: Expiration | null;
        /**
         * Address that is allowed to spend the NFT
         */
        spender: RawAddr;
        /**
         * Position ID, represented as a `String` to match the NFT spec
         */
        token_id: string;
      };
    }
  | {
      revoke: {
        /**
         * Address that is no longer allowed to spend the NFT
         */
        spender: RawAddr;
        /**
         * Position ID, represented as a `String` to match the NFT spec
         */
        token_id: string;
      };
    }
  | {
      approve_all: {
        /**
         * When the approval expires
         */
        expires?: Expiration | null;
        /**
         * Address that is allowed to spend all NFTs by the sending wallet
         */
        operator: RawAddr;
      };
    }
  | {
      revoke_all: {
        /**
         * Address that is no longer allowed to spend all NFTs
         */
        operator: RawAddr;
      };
    };
/**
 * Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)
 */
export type Expiration =
  | {
      at_height: number;
    }
  | {
      at_time: Timestamp;
    }
  | {
      never: {};
    };
/**
 * The kind of liquidity token
 */
export type LiquidityTokenKind = "lp" | "xlp";

/**
 * Helper struct to conveniently update [Config]
 *
 * For each field below, please see the corresponding [Config] field's documentation.
 */
export interface ConfigUpdate {
  borrow_fee_rate_max_annualized?: NonZeroDecimal | null;
  borrow_fee_rate_min_annualized?: NonZeroDecimal | null;
  borrow_fee_sensitivity?: NonZeroDecimal | null;
  carry_leverage?: Decimal256 | null;
  crank_execs?: number | null;
  crank_fee_charged?: Usd | null;
  crank_fee_reward?: Usd | null;
  delta_neutrality_fee_cap?: NonZeroDecimal | null;
  delta_neutrality_fee_sensitivity?: NonZeroDecimal | null;
  delta_neutrality_fee_tax?: Decimal256 | null;
  disable_position_nft_exec?: boolean | null;
  funding_rate_max_annualized?: Decimal256 | null;
  funding_rate_sensitivity?: Decimal256 | null;
  limit_order_fee?: Collateral | null;
  liquidity_cooldown_seconds?: number | null;
  liquifunding_delay_fuzz_seconds?: number | null;
  liquifunding_delay_seconds?: number | null;
  /**
   *
   *             A signed number type with high fidelity.
   *             Similar in spirit to cosmwasm_bignumber::Decimal256 - it is
   *             a more ergonomic wrapper around cosmwasm-std by making more things public
   *             but we also add negative values and other methods as-needed
   *
   */
  max_leverage?: string | null;
  max_liquidity?: MaxLiquidity | null;
  max_xlp_rewards_multiplier?: NonZeroDecimal | null;
  min_xlp_rewards_multiplier?: NonZeroDecimal | null;
  minimum_deposit_usd?: Usd | null;
  mute_events?: boolean | null;
  price_update_too_old_seconds?: number | null;
  protocol_tax?: Decimal256 | null;
  spot_price?: SpotPriceConfig | null;
  staleness_seconds?: number | null;
  target_utilization?: NonZeroDecimal | null;
  trading_fee_counter_collateral?: Decimal256 | null;
  trading_fee_notional_size?: Decimal256 | null;
  unpend_limit?: number | null;
  unstake_period_seconds?: number | null;
}
/**
 * An individual feed used to compose a final spot price
 */
export interface SpotPriceFeed {
  /**
   * The data for this price feed
   */
  data: SpotPriceFeedData;
  /**
   * is this price feed inverted
   */
  inverted: boolean;
}
/**
 * Configuration for pyth
 */
export interface PythConfig {
  /**
   * The age tolerance for pyth price updates
   */
  age_tolerance_seconds: number;
  /**
   * The address of the pyth oracle contract
   */
  contract_address: Addr;
  /**
   * Which network to use for the price service This isn't used for any internal logic, but clients must use the appropriate price service endpoint to match this
   */
  network: PythPriceServiceNetwork;
}
/**
 * Configuration for stride
 */
export interface StrideConfig {
  /**
   * The address of the redemption rate contract
   */
  contract_address: Addr;
}
/**
 * There are two sources of slippage in the protocol: - Change in the oracle price from creation of the message to execution of the message. - Change in delta neutrality fee from creation of the message to execution of the message. Slippage assert tolerance is the tolerance to the sum of the two sources of slippage.
 */
export interface SlippageAssert {
  /**
   * Expected effective price from the sender. To incorporate tolerance on delta neutrality fee, the expected price should be modified by expected fee rate: `price = oracle_price * (1 + fee_rate)` `fee_rate` here is the ratio between the delta neutrality fee amount and notional size delta (in collateral asset).
   */
  price: PriceBaseInQuote;
  /**
   * Max ratio tolerance of actual trade price differing in an unfavorable direction from expected price. Tolerance of 0.01 means max 1% difference.
   */
  tolerance: string;
}
/**
 * Returned by [QueryMsg::LpInfo]
 */
export interface LpInfoResp {
  /**
   * Available crank rewards
   */
  available_crank_rewards: Collateral;
  /**
   * Total available yield, sum of the available LP, xLP, and crank rewards.
   */
  available_yield: Collateral;
  /**
   * Available yield from LP tokens
   */
  available_yield_lp: Collateral;
  /**
   * Available yield from xLP tokens
   */
  available_yield_xlp: Collateral;
  /**
   * Historical information on LP activity
   */
  history: LpHistorySummary;
  /**
   * Liquidity cooldown information, if active.
   */
  liquidity_cooldown?: LiquidityCooldown | null;
  /**
   * This LP amount includes both actual LP tokens and xLP unstaked to LP but not yet collected.
   */
  lp_amount: LpToken;
  /**
   * Collateral backing the LP tokens
   */
  lp_collateral: Collateral;
  /**
   * Current status of an unstaking, if under way
   *
   * This will return `Some` from the time the provider begins an unstaking process until either:
   *
   * 1. They either cancel it, _or_ 2. They unstake all request xLP into LP _and_ collect that LP within the contract.
   */
  unstaking?: UnstakingStatus | null;
  /**
   * This shows the balance of xLP minus any xLP already unstaked.
   */
  xlp_amount: LpToken;
  /**
   * Collateral backing the xLP tokens
   */
  xlp_collateral: Collateral;
}
/**
 * The summary for LP history
 */
export interface LpHistorySummary {
  /**
   * How much collateral was deposited in total
   */
  deposit: Collateral;
  /**
   * Value of the collateral in USD at time of deposit
   */
  deposit_usd: Usd;
  /**
   * Cumulative yield claimed by the provider
   */
  yield: Collateral;
  /**
   * Cumulative yield expressed in USD at time of claiming
   */
  yield_usd: Usd;
}
/**
 * When a liquidity cooldown period will end
 */
export interface LiquidityCooldown {
  /**
   * Timestamp when it will end
   */
  at: Timestamp;
  /**
   * Number of seconds until it will end
   */
  seconds: number;
}

/**
 * Status of an ongoing unstaking process.
 */
export interface UnstakingStatus {
  /**
   * Total amount of LP tokens that have been unstaked and not yet collected
   */
  available: LpToken;
  /**
   * Total amount of LP tokens that have been unstaked and collected
   */
  collected: LpToken;
  /**
   * This will be in the future if unstaking is incomplete
   */
  end: Timestamp;
  /**
   * Total amount of xLP tokens that are still pending unstaking
   */
  pending: LpToken;
  /**
   * When the unstaking began
   */
  start: Timestamp;
  /**
   * Total amount requested to be unstaked
   *
   * Note that this value must be the sum of collected, available, and pending.
   */
  xlp_unstaking: NonZeroDecimal;
  /**
   * Collateral, at current exchange rate, underlying the [UnstakingStatus::xlp_unstaking]
   */
  xlp_unstaking_collateral: Collateral;
}

/**
 * Execute message for liquidity token proxy
 */
export type Cw20ExecuteMsg =
  | {
      transfer: {
        /**
         * Amount to transfer
         */
        amount: Uint128;
        /**
         * Recipient of the funds
         */
        recipient: RawAddr;
      };
    }
  | {
      send: {
        /**
         * Amount to send
         */
        amount: Uint128;
        /**
         * Contract to receive the funds
         */
        contract: RawAddr;
        /**
         * Message to execute on the receiving contract
         */
        msg: Binary;
      };
    }
  | {
      increase_allowance: {
        /**
         * Amount they can spend
         */
        amount: Uint128;
        /**
         * When the allowance expires
         */
        expires?: Expiration | null;
        /**
         * Who is allowed to spend
         */
        spender: RawAddr;
      };
    }
  | {
      decrease_allowance: {
        /**
         * Amount to reduce by
         */
        amount: Uint128;
        /**
         * When the allowance should expire
         */
        expires?: Expiration | null;
        /**
         * Whose spending to reduced
         */
        spender: RawAddr;
      };
    }
  | {
      transfer_from: {
        /**
         * Amount to send
         */
        amount: Uint128;
        /**
         * Owner of the tokens being transferred
         */
        owner: RawAddr;
        /**
         * Recipient of the tokens
         */
        recipient: RawAddr;
      };
    }
  | {
      send_from: {
        /**
         * Amount to send
         */
        amount: Uint128;
        /**
         * Contract to receive the funds
         */
        contract: RawAddr;
        /**
         * Message to execute on the receiving contract
         */
        msg: Binary;
        /**
         * Owner of the tokens being transferred
         */
        owner: RawAddr;
      };
    };

    /**
 * Response for [QueryMsg::OraclePrice]
 */
export interface OraclePriceResp {
  /**
   * The final, composed price. See [QueryMsg::OraclePrice] for more information about this value
   */
  composed_price: PricePoint;
  /**
   * A map of each pyth id used in this market to the price and publish time
   */
  pyth: {
    [k: string]: OraclePriceFeedPythResp;
  };
  /**
   * A map of each sei denom used in this market to the price
   */
  sei: {
    [k: string]: NonZeroDecimal;
  };
  /**
   * A map of each stride denom used in this market to the redemption price
   */
  stride: {
    [k: string]: NonZeroDecimal;
  };
}

/**
 * Part of [OraclePriceResp]
 */
export interface OraclePriceFeedPythResp {
  /**
   * The pyth price
   */
  price: NonZeroDecimal;
  /**
   * The pyth publish time
   */
  publish_time: Timestamp;
}
